import type { IActionRdfMetadataExtract, IActorRdfMetadataExtractOutput,
  IActorRdfMetadataExtractQueryArgs } from '@comunica/bus-rdf-metadata-extract';
import { ActorRdfMetadataExtractQuery } from '@comunica/bus-rdf-metadata-extract';
import type { IActorTest } from '@comunica/core';

import type { UriTemplate } from 'uritemplate';
import { parse as parseUriTemplate } from 'uritemplate';
import * as GRAPHQLLD_CONTEXT from './context.json';

/**
 * An RDF Metadata Extract Actor that extracts all Hydra search forms from the metadata stream.
 */
export class ActorRdfMetadataExtractHydraControlsQuery extends ActorRdfMetadataExtractQuery {
  public static readonly GRAPHQLLD_QUERY: string = `
    query($pageUrl: String) @single(scope: all) {
      id
      graph
      subset(_: $pageUrl)
      search @plural {
        template
        mapping @optional @plural {
          variable
          property
        }
      }
    }`;

  protected readonly parsedUriTemplateCache: Record<string, UriTemplate> = {};

  public constructor(args: IActorRdfMetadataExtractQueryArgs) {
    super(GRAPHQLLD_CONTEXT, ActorRdfMetadataExtractHydraControlsQuery.GRAPHQLLD_QUERY, args);
  }

  public async test(action: IActionRdfMetadataExtract): Promise<IActorTest> {
    return true;
  }

  public async run(action: IActionRdfMetadataExtract): Promise<IActorRdfMetadataExtractOutput> {
    return {
      metadata: {
        searchForms: this.constructHydraControls(await this.queryData(action.metadata, { '?pageUrl': action.url })),
      },
    };
  }

  /**
   * Parse a URI template, or retrieve it from a cache.
   * @param {string} template A URI template string.
   * @return {} A parsed URI template object.
   */
  public parseUriTemplateCached(template: string): UriTemplate {
    const cachedUriTemplate: UriTemplate = this.parsedUriTemplateCache[template];
    if (cachedUriTemplate) {
      return cachedUriTemplate;
    }
    // eslint-disable-next-line no-return-assign
    return this.parsedUriTemplateCache[template] = parseUriTemplate(template);
  }

  /**
   * Find all hydra controls within the given query results.
   * @param queryResults The query results.
   * @return The discovered Hydra search forms.
   */
  public constructHydraControls(queryResults: any): ISearchForms {
    const dataset: string = queryResults.id;
    const values: ISearchForm[] = [];
    if (queryResults.search) {
      for (const search of queryResults.search) {
        const searchTemplate: UriTemplate = this.parseUriTemplateCached(search.template);
        const mappings = (search.mapping || []).reduce((acc: any, entry: any) => {
          acc[entry.property] = entry.variable;
          return acc;
        }, {});
        const getUri = (entries: Record<string, string>): string => searchTemplate
          .expand(Object.keys(entries).reduce((variables: Record<string, string>, key) => {
            variables[mappings[key]] = entries[key];
            return variables;
          }, {}));
        values.push({
          dataset,
          getUri,
          mappings,
          template: search.template,
        });
      }
    }

    return { values };
  }
}

export interface ISearchForm {
  /**
   * The dataset in which the search form is defined.
   */
  dataset: string;
  /**
   * The URI template containing Hydra variables.
   */
  template: string;
  /**
   * The mappings.
   * With as keys the Hydra properties,
   * and as values the Hydra variables
   */
  mappings: Record<string, string>;

  /**
   * Instantiate a uri based on the given Hydra variable values.
   * @param entries Entries with as keys Hydra properties,
   *                and as values Hydra variable values.
   * @return {string} The instantiated URI
   */
  getUri: (entries: Record<string, string>) => string;
}

export interface ISearchForms {
  /**
   * All available search forms.
   */
  values: ISearchForm[];
  // TODO: in the future, a query-based search form getter should be available here.
}
