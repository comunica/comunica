{"version":3,"file":"OverloadTree.js","sourceRoot":"","sources":["OverloadTree.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ICompleteSharedContext } from '../evaluators/evaluatorHelpers/BaseExpressionEvaluator';\nimport type * as E from '../expressions';\nimport { isLiteralTermExpression, TermExpression } from '../expressions';\nimport type { KnownLiteralTypes } from '../util/Consts';\nimport type { GeneralSuperTypeDict, ISuperTypeProvider, OverrideType } from '../util/TypeHandling';\nimport {\n  asGeneralType,\n  asKnownLiteralType,\n  asOverrideType,\n  getSuperTypes,\n  superTypeDictTable,\n  typePromotion,\n} from '../util/TypeHandling';\nimport type { ArgumentType } from './Core';\n\nexport type SearchStack = OverloadTree[];\nexport type ImplementationFunction = (sharedContext: ICompleteSharedContext) => E.SimpleApplication;\nexport type ImplementationFunctionTuple<T> = (sharedContext: ICompleteSharedContext) => E.SimpleApplicationTuple<T>;\ninterface IFunctionArgumentsCacheObj {\n  func?: ImplementationFunction;\n  cache?: FunctionArgumentsCache;\n}\nexport type FunctionArgumentsCache = Record<string, IFunctionArgumentsCacheObj>;\n/**\n * Maps argument types on their specific implementation in a tree like structure.\n * When adding any functionality to this class, make sure you add it to SpecialFunctions as well.\n */\nexport class OverloadTree {\n  private implementation?: ImplementationFunction | undefined;\n  // We need this field. e.g. decimal decimal should be kept even when double double is added.\n  // We use promotion count to check priority.\n  private promotionCount?: number | undefined;\n  private readonly generalOverloads: Record<'term' | E.TermType, OverloadTree>;\n  private readonly literalOverLoads: [OverrideType, OverloadTree][];\n  private readonly depth: number;\n\n  public constructor(private readonly identifier: string, depth?: number) {\n    this.implementation = undefined;\n    this.generalOverloads = Object.create(null);\n    this.literalOverLoads = [];\n    this.depth = depth ?? 0;\n    this.promotionCount = undefined;\n  }\n\n  private getSubtree(overrideType: ArgumentType): OverloadTree | undefined {\n    const generalType = asGeneralType(overrideType);\n    if (generalType) {\n      return this.generalOverloads[generalType];\n    }\n    for (const [ type, overloadTree ] of this.literalOverLoads) {\n      if (overrideType === type) {\n        return overloadTree;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Get the implementation for the types that exactly match @param args .\n   */\n  public getImplementationExact(args: ArgumentType[]): ImplementationFunction | undefined {\n    // eslint-disable-next-line ts/no-this-alias\n    let node: OverloadTree | undefined = this;\n    for (const expression of args) {\n      node = node.getSubtree(expression);\n      if (!node) {\n        return undefined;\n      }\n    }\n    return node.implementation;\n  }\n\n  /**\n   * Searches in a depth first way for the best matching overload. considering this a the tree's root.\n   * @param args the arguments to the function.\n   * @param superTypeProvider\n   * @param functionArgumentsCache\n   */\n  public search(\n    args: E.TermExpression[],\n    superTypeProvider: ISuperTypeProvider,\n    functionArgumentsCache: FunctionArgumentsCache,\n  ):\n    ImplementationFunction | undefined {\n    let cacheIter: IFunctionArgumentsCacheObj | undefined = functionArgumentsCache[this.identifier];\n    let searchIndex = 0;\n    while (searchIndex < args.length && cacheIter?.cache) {\n      const term = args[searchIndex];\n      const literalExpression = isLiteralTermExpression(term);\n      cacheIter = cacheIter.cache[literalExpression ? literalExpression.dataType : term.termType];\n      searchIndex++;\n    }\n    if (searchIndex === args.length && cacheIter?.func) {\n      return cacheIter.func;\n    }\n\n    // SearchStack is a stack of all node's that need to be checked for implementation.\n    // It provides an easy way to keep order in our search.\n    const searchStack: { node: OverloadTree; index: number }[] = [];\n    const startIndex = 0;\n    if (args.length === 0) {\n      return this.implementation;\n    }\n    // GetSubTreeWithArg return a SearchStack containing the node's that should be contacted next.\n    // We also log the index since there is no other way to remember this index.\n    // the provided stack should be pushed on top of our search stack since it also has it's order.\n    searchStack.push(...this.getSubTreeWithArg(args[startIndex], superTypeProvider).map(node =>\n      ({ node, index: startIndex + 1 })));\n    while (searchStack.length > 0) {\n      const { index, node } = <{ node: OverloadTree; index: number }>searchStack.pop();\n      // We check the implementation because it would be possible a path is created but not implemented.\n      // ex: f(double, double, double) and f(term, term). and calling f(double, double).\n      if (index === args.length && node.implementation) {\n        this.addToCache(functionArgumentsCache, args, node.implementation);\n        return node.implementation;\n      }\n      searchStack.push(...node.getSubTreeWithArg(args[index], superTypeProvider).map(item =>\n        ({ node: item, index: index + 1 })));\n    }\n    // Calling a function with one argument but finding no implementation should return no implementation.\n    // Not even the one with no arguments.\n    return undefined;\n  }\n\n  private addToCache(\n    functionArgumentsCache: FunctionArgumentsCache,\n    args: E.TermExpression[],\n    func?: ImplementationFunction | undefined,\n  ): void {\n    function getDefault(lruCache: FunctionArgumentsCache, key: string): IFunctionArgumentsCacheObj {\n      if (!(key in lruCache)) {\n        lruCache[key] = {};\n      }\n      return lruCache[key];\n    }\n    let cache = getDefault(functionArgumentsCache, this.identifier);\n    for (const term of args) {\n      const literalExpression = isLiteralTermExpression(term);\n      const key = literalExpression ? literalExpression.dataType : term.termType;\n      cache.cache = cache.cache ?? {};\n      cache = getDefault(cache.cache, key);\n    }\n    cache.func = func;\n  }\n\n  /**\n   * Adds an overload to the tree structure considering this as the tree's root.\n   * @param argumentTypes a list of argumentTypes that would need to be provided in\n   * the same order to get the implementation.\n   * @param func the implementation for this overload.\n   */\n  public addOverload(argumentTypes: ArgumentType[], func: ImplementationFunction): void {\n    this._addOverload([ ...argumentTypes ], func, 0);\n  }\n\n  private _addOverload(argumentTypes: ArgumentType[], func: ImplementationFunction, promotionCount: number): void {\n    const [ argumentType, ..._argumentTypes ] = argumentTypes;\n    if (!argumentType) {\n      if (this.promotionCount === undefined || promotionCount <= this.promotionCount) {\n        this.promotionCount = promotionCount;\n        this.implementation = func;\n      }\n      return;\n    }\n    let nextTree = this.getSubtree(argumentType);\n    if (!nextTree) {\n      const newNode = new OverloadTree(this.identifier, this.depth + 1);\n      const generalType = asGeneralType(argumentType);\n      if (generalType) {\n        this.generalOverloads[generalType] = newNode;\n      }\n      const overrideType = asOverrideType(argumentType);\n      if (overrideType) {\n        this.literalOverLoads.push([ overrideType, newNode ]);\n      }\n      nextTree = newNode;\n    }\n    nextTree._addOverload(_argumentTypes, func, promotionCount);\n\n    if (typePromotion[argumentType]) {\n      for (const ret of typePromotion[argumentType]!) {\n        this.addPromotedOverload(\n          ret.typeToPromote,\n          func,\n          ret.conversionFunction,\n          _argumentTypes,\n          promotionCount,\n        );\n      }\n    }\n  }\n\n  private addPromotedOverload(\n    typeToPromote: OverrideType,\n    func: ImplementationFunction,\n    conversionFunction: (arg: E.TermExpression) => E.TermExpression,\n    argumentTypes: ArgumentType[],\n    promotionCount: number,\n  ): void {\n    let nextTree = this.getSubtree(typeToPromote);\n    if (!nextTree) {\n      const newNode = new OverloadTree(this.identifier, this.depth + 1);\n      this.literalOverLoads.push([ typeToPromote, newNode ]);\n      nextTree = newNode;\n    }\n    nextTree._addOverload(argumentTypes, funcConf => args => func(funcConf)([\n      ...args.slice(0, this.depth),\n      conversionFunction(args[this.depth]),\n      ...args.slice(this.depth + 1, args.length),\n    ]), promotionCount + 1);\n  }\n\n  /**\n   * @param arg term to try and match to possible overloads of this node.\n   * @param openWorldType interface allowing to discover relations between types.\n   * @returns SearchStack a stack with top element the next node that should be asked for implementation or overload.\n   */\n  private getSubTreeWithArg(arg: E.TermExpression, openWorldType: ISuperTypeProvider): SearchStack {\n    const res: SearchStack = [];\n    const literalExpression = isLiteralTermExpression(arg);\n    // These types refer to Type exported by lib/util/Consts.ts\n    if (this.generalOverloads.term) {\n      res.push(this.generalOverloads.term);\n    }\n    // TermTypes are defined in E.TermType.\n    if (this.generalOverloads[arg.termType]) {\n      res.push(this.generalOverloads[arg.termType]);\n    }\n    if (literalExpression) {\n      // Defending implementation. Mainly the scary sort.\n      // This function has cost O(n) + O(m * log(m)) with n = amount of overloads and m = amount of matched overloads\n      // We map over each of the overloads, filter only the once that can be used (this is normally 1 or 2).\n      // The sort function on an array with 1 or 2 arguments will be negligible.\n      const concreteType = asKnownLiteralType(literalExpression.dataType);\n      let subExtensionTable: GeneralSuperTypeDict;\n      if (concreteType) {\n        // Concrete dataType is known by expression-evaluator.\n        subExtensionTable = superTypeDictTable[concreteType];\n      } else {\n        // Datatype is a custom datatype\n        subExtensionTable = getSuperTypes(literalExpression.dataType, openWorldType);\n      }\n      const matches: [number, OverloadTree][] = this.literalOverLoads.filter(([ matchType, _ ]) =>\n        matchType in subExtensionTable)\n        .map(([ matchType, tree ]) => [ subExtensionTable[<KnownLiteralTypes> matchType], tree ]);\n      // eslint-disable-next-line unused-imports/no-unused-vars\n      matches.sort(([ prioA, matchTypeA ], [ prioB, matchTypeB ]) => prioA - prioB);\n      res.push(...matches.map(([ _, sortedType ]) => sortedType));\n    }\n    return res;\n  }\n}\n"]}