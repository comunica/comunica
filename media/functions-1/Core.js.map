{"version":3,"file":"Core.js","sourceRoot":"","sources":["Core.ts"],"names":[],"mappings":";;;AAIA,sCAAsC;AA6BtC,MAAsB,YAAY;IAIhC,YAA6B,QAAkB,EAAE,UAAiC;QAArD,aAAQ,GAAR,QAAQ,CAAU;QAK/C;;;;WAIG;QACI,UAAK,GAAG,CAAC,IAAwB,EAAE,OAA+B,EACxD,EAAE;YACjB,MAAM,gBAAgB,GACpB,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,OAAO,CAAC,iBAAiB,EAAE,OAAO,CAAC,sBAAsB,CAAC;gBAC/E,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;YAChC,OAAO,gBAAgB,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC;QACzC,CAAC,CAAC;QAfA,IAAI,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC;QAC9B,IAAI,CAAC,SAAS,GAAG,UAAU,CAAC,SAAS,CAAC;IACxC,CAAC;IAiBD;;;;;;;;;;OAUG;IACK,SAAS,CACf,IAAwB,EACxB,iBAAqC,EACrC,sBAA8C;QAE9C,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,EAAE,iBAAiB,EAAE,sBAAsB,CAAC,CAAC;IAChF,CAAC;CACF;AA1CD,oCA0CC;AAED,+EAA+E;AAE/E;;;;;;;;;;;;;;;;;GAiBG;AACH,MAAa,eAAgB,SAAQ,YAA+B;IAGlE,YAAmB,EAAqB,EAAE,UAAiC;QACzE,KAAK,CAAC,EAAE,EAAE,UAAU,CAAC,CAAC;QAHd,kBAAa,GAAW,SAAS,CAAC;IAI5C,CAAC;IAES,kBAAkB,CAAC,IAAwB;QACnD,MAAM,IAAI,GAAG,CAAC,oBAAoB,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;IAC1D,CAAC;CACF;AAVD,0CAUC;AAED,+EAA+E;AAC/E,MAAa,aAAc,SAAQ,YAA6B;IAG9D,YAAmB,EAAmB,EAAE,UAAiC;QACvE,KAAK,CAAC,EAAE,EAAE,UAAU,CAAC,CAAC;QAHd,kBAAa,GAAW,OAAO,CAAC;IAI1C,CAAC;IAES,kBAAkB,CAAC,IAAwB;QACnD,MAAM,IAAI,GAAG,CAAC,oBAAoB,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;IAC1D,CAAC;CACF;AAVD,sCAUC;AAED,+EAA+E;AAC/E;;;;;;;;;;;;;;GAcG;AACH,MAAa,eAAe;IAO1B,YAA0B,QAA2B,EAAE,UAA8B;QAA3D,aAAQ,GAAR,QAAQ,CAAmB;QAN9C,kBAAa,GAAW,SAAS,CAAC;QAOvC,IAAI,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC;QAC9B,IAAI,CAAC,kBAAkB,GAAG,UAAU,CAAC,kBAAkB,CAAC;QACxD,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC,UAAU,CAAC;QACxC,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC,UAAU,IAAI,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC3E,CAAC;CACF;AAbD,0CAaC;AAED,SAAS,iBAAiB,CAAC,KAAa;IACtC,OAAO,CAAC,IAAoB,EAAW,EAAE;QACvC,kEAAkE;QAClE,IAAI,KAAK,KAAK,MAAM,CAAC,iBAAiB,EAAE,CAAC;YACvC,OAAO,IAAI,CAAC;QACd,CAAC;QAED,OAAO,IAAI,CAAC,MAAM,KAAK,KAAK,CAAC;IAC/B,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { ICompleteSharedContext } from '../evaluators/evaluatorHelpers/BaseExpressionEvaluator';\nimport type * as E from '../expressions';\nimport type * as C from '../util/Consts';\nimport * as Err from '../util/Errors';\nimport type { ISuperTypeProvider } from '../util/TypeHandling';\nimport type { ImplementationFunction, OverloadTree, FunctionArgumentsCache } from './OverloadTree';\n\nexport interface IEvalSharedContext extends ICompleteSharedContext {\n  args: E.Expression[];\n  mapping: RDF.Bindings;\n}\nexport interface IEvalContext<Term, BNode> extends IEvalSharedContext {\n  bnode?: (input?: string) => BNode;\n  evaluate: (expr: E.Expression, mapping: RDF.Bindings) => Term;\n}\n\nexport type EvalContextAsync = IEvalContext<Promise<E.TermExpression>, Promise<RDF.BlankNode>>;\nexport type EvalContextSync = IEvalContext<E.TermExpression, RDF.BlankNode>;\n\n// ----------------------------------------------------------------------------\n// Overloaded Functions\n// ----------------------------------------------------------------------------\n\n// Function and operator arguments are 'flattened' in the SPARQL spec.\n// If the argument is a literal, the datatype often also matters.\nexport type ArgumentType = 'term' | E.TermType | C.TypeURL | C.TypeAlias;\n\nexport interface IOverloadedDefinition {\n  arity: number | number[];\n  overloads: OverloadTree;\n}\n\nexport abstract class BaseFunction<Operator> {\n  public arity: number | number[];\n  private readonly overloads: OverloadTree;\n\n  protected constructor(public operator: Operator, definition: IOverloadedDefinition) {\n    this.arity = definition.arity;\n    this.overloads = definition.overloads;\n  }\n\n  /**\n   * A function application works by monomorphing the function to a specific\n   * instance depending on the runtime types. We then just apply this function\n   * to the args.\n   */\n  public apply = (args: E.TermExpression[], context: ICompleteSharedContext):\n  E.TermExpression => {\n    const concreteFunction =\n      this.monomorph(args, context.superTypeProvider, context.functionArgumentsCache) ??\n      this.handleInvalidTypes(args);\n    return concreteFunction(context)(args);\n  };\n\n  protected abstract handleInvalidTypes(args: E.TermExpression[]): never;\n\n  /**\n   * We monomorph by checking the map of overloads for keys corresponding\n   * to the runtime types. We start by checking for an implementation for the\n   * most concrete types (integer, string, date, IRI), if we find none,\n   * we consider their term types (literal, blank, IRI), and lastly we consider\n   * all arguments as generic terms.\n   *\n   * Another option would be to populate the overloads with an implementation\n   * for every concrete type when the function is generic over termtypes or\n   * terms.\n   */\n  private monomorph(\n    args: E.TermExpression[],\n    superTypeProvider: ISuperTypeProvider,\n    functionArgumentsCache: FunctionArgumentsCache,\n  ): ImplementationFunction | undefined {\n    return this.overloads.search(args, superTypeProvider, functionArgumentsCache);\n  }\n}\n\n// Regular Functions ----------------------------------------------------------\n\n/**\n * Varying kinds of functions take arguments of different types on which the\n * specific behaviour is dependant. Although their behaviour is often varying,\n * it is always relatively simple, and better suited for synced behaviour.\n * The types of their arguments are always terms, but might differ in\n * their term-type (eg: iri, literal),\n * their specific literal type (eg: string, integer),\n * their arity (see BNODE),\n * or even their specific numeric type (eg: integer, float).\n *\n * Examples include:\n *  - Arithmetic operations such as: *, -, /, +\n *  - Bool operators such as: =, !=, <=, <, ...\n *  - Functions such as: str, IRI\n *\n * See also: https://www.w3.org/TR/sparql11-query/#func-rdfTerms\n * and https://www.w3.org/TR/sparql11-query/#OperatorMapping\n */\nexport class RegularFunction extends BaseFunction<C.RegularOperator> {\n  protected functionClass = <const> 'regular';\n\n  public constructor(op: C.RegularOperator, definition: IOverloadedDefinition) {\n    super(op, definition);\n  }\n\n  protected handleInvalidTypes(args: E.TermExpression[]): never {\n    throw new Err.InvalidArgumentTypes(args, this.operator);\n  }\n}\n\n// Named Functions ------------------------------------------------------------\nexport class NamedFunction extends BaseFunction<C.NamedOperator> {\n  protected functionClass = <const> 'named';\n\n  public constructor(op: C.NamedOperator, definition: IOverloadedDefinition) {\n    super(op, definition);\n  }\n\n  protected handleInvalidTypes(args: E.TermExpression[]): never {\n    throw new Err.InvalidArgumentTypes(args, this.operator);\n  }\n}\n\n// Special Functions ----------------------------------------------------------\n/**\n * Special Functions are those that don't really fit in sensible categories and\n * have extremely heterogeneous signatures that make them impossible to abstract\n * over. They are small in number, and their behaviour is often complex and open\n * for multiple correct implementations with different trade-offs.\n *\n * Due to their varying nature, they need all available information present\n * during evaluation. This reflects in the signature of the apply() method.\n *\n * They need access to an evaluator to be able to even implement their logic.\n * Especially relevant for IF, and the logical connectives.\n *\n * They can have both sync and async implementations, and both would make sense\n * in some contexts.\n */\nexport class SpecialFunction {\n  public functionClass = <const> 'special';\n  public arity: number;\n  public applySynchronously: E.SpecialApplicationSync;\n  public applyAsync: E.SpecialApplicationAsync;\n  public checkArity: (args: E.Expression[]) => boolean;\n\n  public constructor(public operator: C.SpecialOperator, definition: ISpecialDefinition) {\n    this.arity = definition.arity;\n    this.applySynchronously = definition.applySynchronously;\n    this.applyAsync = definition.applyAsync;\n    this.checkArity = definition.checkArity ?? defaultArityCheck(this.arity);\n  }\n}\n\nfunction defaultArityCheck(arity: number): (args: E.Expression[]) => boolean {\n  return (args: E.Expression[]): boolean => {\n    // Infinity is used to represent var-args, so it's always correct.\n    if (arity === Number.POSITIVE_INFINITY) {\n      return true;\n    }\n\n    return args.length === arity;\n  };\n}\n\nexport interface ISpecialDefinition {\n  arity: number;\n  applyAsync: E.SpecialApplicationAsync;\n  applySynchronously: E.SpecialApplicationSync;\n  checkArity?: (args: E.Expression[]) => boolean;\n}\n"]}