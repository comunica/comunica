{"version":3,"file":"Helpers.js","sourceRoot":"","sources":["Helpers.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * These helpers provide a (albeit inflexible) DSL for writing function\n * definitions for the SPARQL functions.\n */\nimport type * as RDF from '@rdfjs/types';\nimport { DataFactory } from 'rdf-data-factory';\nimport type { ICompleteSharedContext } from '../evaluators/evaluatorHelpers/BaseExpressionEvaluator';\nimport type { Literal, TermExpression, Quad, ISerializable } from '../expressions';\nimport * as E from '../expressions';\nimport { NonLexicalLiteral } from '../expressions';\nimport * as C from '../util/Consts';\nimport { TypeURL } from '../util/Consts';\nimport type { IDateTimeRepresentation } from '../util/DateTimeHelpers';\nimport * as Err from '../util/Errors';\nimport type { ArgumentType } from './Core';\nimport type { ImplementationFunction, ImplementationFunctionTuple } from './OverloadTree';\nimport { OverloadTree } from './OverloadTree';\n\ntype Term = E.TermExpression;\n\nconst DF = new DataFactory();\n\nexport function declare(identifier: string): Builder {\n  return new Builder(identifier);\n}\n\nexport class Builder {\n  private readonly overloadTree: OverloadTree;\n  private collected: boolean;\n\n  public constructor(identifier: string) {\n    this.overloadTree = new OverloadTree(identifier);\n    this.collected = false;\n  }\n\n  public collect(): OverloadTree {\n    if (this.collected) {\n      // Only 1 time allowed because we can't copy a tree. (And we don't need this).\n      throw new Error('Builders can only be collected once!');\n    }\n    this.collected = true;\n    return this.overloadTree;\n  }\n\n  private static wrapInvalidLexicalProtected(func: ImplementationFunction): ImplementationFunction {\n    return (context: ICompleteSharedContext) => (args: TermExpression[]) => {\n      for (const [ index, arg ] of args.entries()) {\n        if (arg instanceof NonLexicalLiteral) {\n          throw new Err.InvalidLexicalForm(args[index].toRDF());\n        }\n      }\n      return func(context)(args);\n    };\n  }\n\n  public set(\n    argTypes: [],\n    func: ImplementationFunctionTuple<[]>,\n    addInvalidHandling?: boolean,\n  ): Builder;\n  public set<T1 extends TermExpression>(\n    argTypes: [ArgumentType],\n    func: ImplementationFunctionTuple<[T1]>,\n    addInvalidHandling?: boolean,\n  ): Builder;\n  public set<T1 extends TermExpression, T2 extends TermExpression>(\n    argTypes: [ArgumentType, ArgumentType],\n    func: ImplementationFunctionTuple<[T1, T2]>,\n    addInvalidHandling?: boolean,\n  ): Builder;\n  public set<T1 extends TermExpression, T2 extends TermExpression, T3 extends TermExpression>(\n    argTypes: [ArgumentType, ArgumentType, ArgumentType],\n    func: ImplementationFunctionTuple<[T1, T2, T3]>,\n    addInvalidHandling?: boolean,\n  ): Builder;\n  public set<\n    T1 extends TermExpression,\n    T2 extends TermExpression,\n    T3 extends TermExpression,\n    T4 extends TermExpression,\n  >(\n    argTypes: [ArgumentType, ArgumentType, ArgumentType, ArgumentType],\n    func: ImplementationFunctionTuple<[T1, T2, T3, T4]>,\n    addInvalidHandling?: boolean,\n  ): Builder;\n  public set(argTypes: ArgumentType[], func: ImplementationFunction, addInvalidHandling?: boolean): Builder;\n  public set(argTypes: ArgumentType[], func: ImplementationFunction, addInvalidHandling = true): Builder {\n    this.overloadTree.addOverload(argTypes, addInvalidHandling ? Builder.wrapInvalidLexicalProtected(func) : func);\n    return this;\n  }\n\n  public copy({ from, to }: { from: ArgumentType[]; to: ArgumentType[] }): Builder {\n    const impl = this.overloadTree.getImplementationExact(from);\n    if (!impl) {\n      throw new Err.UnexpectedError(\n        'Tried to copy implementation, but types not found',\n        { from, to },\n      );\n    }\n    return this.set(to, impl);\n  }\n\n  public onUnary<T extends Term>(type: ArgumentType, op: (context: ICompleteSharedContext) =>\n  (val: T) => Term, addInvalidHandling = true): Builder {\n    return this.set([ type ], context => ([ val ]: [T]) => op(context)(val), addInvalidHandling);\n  }\n\n  public onUnaryTyped<T extends ISerializable>(\n    type: ArgumentType,\n    op: (context: ICompleteSharedContext) => (val: T) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set([ type ], context => ([ val ]: [E.Literal<T>]) => op(context)(val.typedValue), addInvalidHandling);\n  }\n\n  public onBinary<L extends Term, R extends Term>(\n    types: [ArgumentType, ArgumentType],\n    op: (context: ICompleteSharedContext) => (left: L, right: R) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(types, context => ([ left, right ]: [L, R]) => op(context)(left, right), addInvalidHandling);\n  }\n\n  public onBinaryTyped<L extends ISerializable, R extends ISerializable>(\n    types: [ArgumentType, ArgumentType],\n    op: (context: ICompleteSharedContext) => (left: L, right: R) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(\n      types,\n      context => ([ left, right ]: [E.Literal<L>, E.Literal<R>]) => op(context)(left.typedValue, right.typedValue),\n      addInvalidHandling,\n    );\n  }\n\n  public onTernaryTyped<A1 extends ISerializable, A2 extends ISerializable, A3 extends ISerializable>(\n    types: [ArgumentType, ArgumentType, ArgumentType],\n    op: (context: ICompleteSharedContext)\n    => (a1: A1, a2: A2, a3: A3) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(types, context => ([ a1, a2, a3 ]: [E.Literal<A1>, E.Literal<A2>, E.Literal<A3>]) =>\n      op(context)(a1.typedValue, a2.typedValue, a3.typedValue), addInvalidHandling);\n  }\n\n  public onTernary<A1 extends Term, A2 extends Term, A3 extends Term>(\n    types: [ArgumentType, ArgumentType, ArgumentType],\n    op: (context: ICompleteSharedContext) => (a1: A1, a2: A2, a3: A3) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(types, context => ([ a1, a2, a3 ]: [A1, A2, A3]) => op(context)(a1, a2, a3), addInvalidHandling);\n  }\n\n  public onQuaternaryTyped<\n    A1 extends ISerializable,\nA2 extends ISerializable,\nA3 extends ISerializable,\nA4 extends ISerializable,\n>(\n    types: [ArgumentType, ArgumentType, ArgumentType, ArgumentType],\n    op: (context: ICompleteSharedContext) => (a1: A1, a2: A2, a3: A3, a4: A4) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(types, context =>\n      ([ a1, a2, a3, a4 ]: [E.Literal<A1>, E.Literal<A2>, E.Literal<A3>, E.Literal<A4>]) =>\n        op(context)(a1.typedValue, a2.typedValue, a3.typedValue, a4.typedValue), addInvalidHandling);\n  }\n\n  public onTerm1<T extends Term>(\n    op: (context: ICompleteSharedContext) => (term: T) => Term,\naddInvalidHandling = false,\n  ): Builder {\n    return this.set(\n      [ 'term' ],\n      context => ([ term ]: [T]) => op(context)(term),\n      addInvalidHandling,\n    );\n  }\n\n  public onTerm3(op: (context: ICompleteSharedContext) => (t1: Term, t2: Term, t3: Term) => Term): Builder {\n    return this.set(\n      [ 'term', 'term', 'term' ],\n      context => ([ t1, t2, t3 ]: [Term, Term, Term]) => op(context)(t1, t2, t3),\n    );\n  }\n\n  public onQuad1(op: (context: ICompleteSharedContext) => (term: Term & Quad) => Term): Builder {\n    return this.set([ 'quad' ], context => ([ term ]: [Term & Quad]) => op(context)(term));\n  }\n\n  public onLiteral1<T extends ISerializable>(\n    op: (context: ICompleteSharedContext) => (lit: E.Literal<T>) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(\n      [ 'literal' ],\n      context => ([ term ]: [E.Literal<T>]) => op(context)(term),\n      addInvalidHandling,\n    );\n  }\n\n  public onBoolean1(\n    op: (context: ICompleteSharedContext) => (lit: E.BooleanLiteral) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(\n      [ C.TypeURL.XSD_BOOLEAN ],\n      context => ([ lit ]: [E.BooleanLiteral]) => op(context)(lit),\n      addInvalidHandling,\n    );\n  }\n\n  public onBoolean1Typed(\n    op: (context: ICompleteSharedContext) => (lit: boolean) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(\n      [ C.TypeURL.XSD_BOOLEAN ],\n      context => ([ lit ]: [E.BooleanLiteral]) => op(context)(lit.typedValue),\n      addInvalidHandling,\n    );\n  }\n\n  public onString1(\n    op: (context: ICompleteSharedContext) => (lit: E.Literal<string>) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(\n      [ C.TypeURL.XSD_STRING ],\n      context => ([ lit ]: [E.Literal<string>]) => op(context)(lit),\n      addInvalidHandling,\n    );\n  }\n\n  public onString1Typed(\n    op: (context: ICompleteSharedContext) => (lit: string) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(\n      [ C.TypeURL.XSD_STRING ],\n      context => ([ lit ]: [E.Literal<string>]) => op(context)(lit.typedValue),\n      addInvalidHandling,\n    );\n  }\n\n  public onLangString1(\n    op: (context: ICompleteSharedContext) => (lit: E.LangStringLiteral) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(\n      [ C.TypeURL.RDF_LANG_STRING ],\n      context => ([ lit ]: [E.LangStringLiteral]) => op(context)(lit),\n      addInvalidHandling,\n    );\n  }\n\n  public onStringly1(\n    op: (context: ICompleteSharedContext) => (lit: E.Literal<string>) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(\n      [ C.TypeAlias.SPARQL_STRINGLY ],\n      context => ([ lit ]: [E.Literal<string>]) => op(context)(lit),\n      addInvalidHandling,\n    );\n  }\n\n  public onStringly1Typed(\n    op: (context: ICompleteSharedContext) => (lit: string) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(\n      [ C.TypeAlias.SPARQL_STRINGLY ],\n      context => ([ lit ]: [E.Literal<string>]) => op(context)(lit.typedValue),\n      addInvalidHandling,\n    );\n  }\n\n  public onNumeric1(\n    op: (context: ICompleteSharedContext) => (val: E.NumericLiteral) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this.set(\n      [ C.TypeAlias.SPARQL_NUMERIC ],\n      context => ([ val ]: [E.NumericLiteral]) => op(context)(val),\n      addInvalidHandling,\n    );\n  }\n\n  public onDateTime1(\n    op: (context: ICompleteSharedContext) => (date: E.DateTimeLiteral) => Term,\naddInvalidHandling = true,\n  ): Builder {\n    return this\n      .set(\n        [ C.TypeURL.XSD_DATE_TIME ],\n        context => ([ val ]: [E.DateTimeLiteral]) => op(context)(val),\n        addInvalidHandling,\n      );\n  }\n\n  /**\n   * We return the base types and not the provided types because we don't want to create invalid terms.\n   * Providing negative number to a function unary - for example should not\n   * return a term of type negative number having a positive value.\n   * @param op the numeric operator performed\n   * @param addInvalidHandling whether to add invalid handling,\n   *   whether to add @param op in @see wrapInvalidLexicalProtected\n   */\n  public numericConverter(\n    op: (context: ICompleteSharedContext) => (val: number) => number,\naddInvalidHandling = true,\n  ): Builder {\n    const evalHelper = (context: ICompleteSharedContext) => (arg: Term): number =>\n      op(context)((<Literal<number>>arg).typedValue);\n    return this.onUnary(TypeURL.XSD_INTEGER, context => arg =>\n      integer(evalHelper(context)(arg)), addInvalidHandling)\n      .onUnary(TypeURL.XSD_DECIMAL, context => arg =>\n        decimal(evalHelper(context)(arg)), addInvalidHandling)\n      .onUnary(TypeURL.XSD_FLOAT, context => arg =>\n        float(evalHelper(context)(arg)), addInvalidHandling)\n      .onUnary(TypeURL.XSD_DOUBLE, context => arg =>\n        double(evalHelper(context)(arg)), addInvalidHandling);\n  }\n\n  /**\n   * !!! Be aware when using this function, it will create different overloads with different return types !!!\n   * Arithmetic operators take 2 numeric arguments, and return a single numerical\n   * value. The type of the return value is heavily dependent on the types of the\n   * input arguments. In JS everything is a double, but in SPARQL it is not.\n   *\n   * The different arguments are handled by type promotion and subtype substitution.\n   * The way numeric function arguments work is described here:\n   * https://www.w3.org/TR/xpath20/#mapping\n   * Above url is referenced in the sparql spec: https://www.w3.org/TR/sparql11-query/#OperatorMapping\n   */\n  public arithmetic(\n    op: (context: ICompleteSharedContext) => (left: number, right: number) => number,\naddInvalidHandling = true,\n  ): Builder {\n    const evalHelper = (context: ICompleteSharedContext) => (left: Term, right: Term): number =>\n      op(context)((<Literal<number>>left).typedValue, (<Literal<number>>right).typedValue);\n    return this.onBinary([ TypeURL.XSD_INTEGER, TypeURL.XSD_INTEGER ], context => (left, right) =>\n      integer(evalHelper(context)(left, right)), addInvalidHandling)\n      .onBinary([ TypeURL.XSD_DECIMAL, TypeURL.XSD_DECIMAL ], context => (left, right) =>\n        decimal(evalHelper(context)(left, right)), addInvalidHandling)\n      .onBinary([ TypeURL.XSD_FLOAT, TypeURL.XSD_FLOAT ], context => (left, right) =>\n        float(evalHelper(context)(left, right)), addInvalidHandling)\n      .onBinary([ TypeURL.XSD_DOUBLE, TypeURL.XSD_DOUBLE ], context => (left, right) =>\n        double(evalHelper(context)(left, right)), addInvalidHandling);\n  }\n\n  public numberTest(test: (context: ICompleteSharedContext) => (left: number, right: number) => boolean): Builder {\n    return this.numeric(context => ([ left, right ]: E.NumericLiteral[]) => {\n      const result = test(context)(left.typedValue, right.typedValue);\n      return bool(result);\n    });\n  }\n\n  public stringTest(\n    test: (context: ICompleteSharedContext) => (left: string, right: string) => boolean,\naddInvalidHandling = true,\n  ): Builder {\n    return this\n      .set(\n        [ C.TypeURL.XSD_STRING, C.TypeURL.XSD_STRING ],\n        context => ([ left, right ]: E.StringLiteral[]) => {\n          const result = test(context)(left.typedValue, right.typedValue);\n          return bool(result);\n        },\n        addInvalidHandling,\n      );\n  }\n\n  public booleanTest(\n    test: (context: ICompleteSharedContext) => (left: boolean, right: boolean) => boolean,\naddInvalidHandling = true,\n  ): Builder {\n    return this\n      .set(\n        [ C.TypeURL.XSD_BOOLEAN, C.TypeURL.XSD_BOOLEAN ],\n        context => ([ left, right ]: E.BooleanLiteral[]) => {\n          const result = test(context)(left.typedValue, right.typedValue);\n          return bool(result);\n        },\n        addInvalidHandling,\n      );\n  }\n\n  public dateTimeTest(test: (context: ICompleteSharedContext)\n  => (left: IDateTimeRepresentation, right: IDateTimeRepresentation) => boolean, addInvalidHandling = true): Builder {\n    return this\n      .set(\n        [ C.TypeURL.XSD_DATE_TIME, C.TypeURL.XSD_DATE_TIME ],\n        context => ([ left, right ]: E.DateTimeLiteral[]) => {\n          const result = test(context)(left.typedValue, right.typedValue);\n          return bool(result);\n        },\n        addInvalidHandling,\n      );\n  }\n\n  public numeric<T extends TermExpression>(op: ImplementationFunctionTuple<[T, T]>): Builder {\n    return this.set([ C.TypeAlias.SPARQL_NUMERIC, C.TypeAlias.SPARQL_NUMERIC ], op);\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Literal Construction helpers\n// ----------------------------------------------------------------------------\n\nexport function bool(val: boolean): E.BooleanLiteral {\n  return new E.BooleanLiteral(val);\n}\n\nexport function integer(num: number): E.IntegerLiteral {\n  return new E.IntegerLiteral(num);\n}\n\nexport function decimal(num: number): E.DecimalLiteral {\n  return new E.DecimalLiteral(num);\n}\n\nexport function float(num: number): E.FloatLiteral {\n  return new E.FloatLiteral(num);\n}\n\nexport function double(num: number): E.DoubleLiteral {\n  return new E.DoubleLiteral(num);\n}\n\nexport function string(str: string): E.StringLiteral {\n  return new E.StringLiteral(str);\n}\n\nexport function langString(str: string, lang: string): E.LangStringLiteral {\n  return new E.LangStringLiteral(str, lang);\n}\n\nexport function dateTime(date: IDateTimeRepresentation, str: string): E.DateTimeLiteral {\n  return new E.DateTimeLiteral(date, str);\n}\n\nexport function expressionToVar(variableExpression: E.VariableExpression): RDF.Variable {\n  return DF.variable(variableExpression.name.slice(1));\n}\n"]}