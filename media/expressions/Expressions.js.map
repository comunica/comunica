{"version":3,"file":"Expressions.js","sourceRoot":"","sources":["Expressions.ts"],"names":[],"mappings":";;;AAIA,IAAY,cAUX;AAVD,WAAY,cAAc;IACxB,yCAAuB,CAAA;IACvB,yCAAuB,CAAA;IACvB,iCAAe,CAAA;IACf,uCAAqB,CAAA;IACrB,qDAAmC,CAAA;IACnC,+BAAa,CAAA;IACb,uCAAqB,CAAA;IACrB,mDAAiC,CAAA;IACjC,iDAA+B,CAAA;AACjC,CAAC,EAVW,cAAc,8BAAd,cAAc,QAUzB;AA8DD,2CAA2C;AAC3C,SAAgB,UAAU,CAAC,IAAY;IACrC,IAAI,IAAI,KAAK,WAAW,IAAI,IAAI,KAAK,SAAS,IAAI,IAAI,KAAK,WAAW,IAAI,IAAI,KAAK,MAAM,EAAE,CAAC;QAC1F,OAAO,IAAI,CAAC;IACd,CAAC;IACD,OAAO,SAAS,CAAC;AACnB,CAAC;AALD,gCAKC","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport type { EvalContextAsync, EvalContextSync } from '../functions';\n\nexport enum ExpressionType {\n  Aggregate = 'aggregate',\n  Existence = 'existence',\n  Named = 'named',\n  Operator = 'operator',\n  SpecialOperator = 'specialOperator',\n  Term = 'term',\n  Variable = 'variable',\n  AsyncExtension = 'asyncExtension',\n  SyncExtension = 'syncExtension',\n}\n\nexport type Expression =\n  AggregateExpression |\n  ExistenceExpression |\n  NamedExpression |\n  OperatorExpression |\n  SpecialOperatorExpression |\n  TermExpression |\n  VariableExpression |\n  AsyncExtensionExpression |\n  SyncExtensionExpression;\n\nexport interface IExpressionProps {\n  expressionType: ExpressionType;\n}\n\nexport type AggregateExpression = IExpressionProps & {\n  expressionType: ExpressionType.Aggregate;\n  name: string;\n  expression: Algebra.AggregateExpression;\n};\n\nexport type ExistenceExpression = IExpressionProps & {\n  expressionType: ExpressionType.Existence;\n  expression: Algebra.ExistenceExpression;\n};\n\nexport type NamedExpression = IExpressionProps & {\n  expressionType: ExpressionType.Named;\n  name: RDF.NamedNode;\n  apply: SimpleApplication;\n  args: Expression[];\n};\n\nexport type AsyncExtensionExpression = IExpressionProps & {\n  expressionType: ExpressionType.AsyncExtension;\n  name: RDF.NamedNode;\n  apply: AsyncExtensionApplication;\n  args: Expression[];\n};\n\nexport type SyncExtensionExpression = IExpressionProps & {\n  expressionType: ExpressionType.SyncExtension;\n  name: RDF.NamedNode;\n  apply: SimpleApplication;\n  args: Expression[];\n};\n\nexport type OperatorExpression = IExpressionProps & {\n  expressionType: ExpressionType.Operator;\n  args: Expression[];\n  apply: SimpleApplication;\n};\n\nexport type SpecialOperatorExpression = IExpressionProps & {\n  expressionType: ExpressionType.SpecialOperator;\n  args: Expression[];\n  applyAsync: SpecialApplicationAsync;\n  applySynchronously: SpecialApplicationSync;\n};\n\n// TODO: Create alias Term = TermExpression\nexport function asTermType(type: string): TermType | undefined {\n  if (type === 'namedNode' || type === 'literal' || type === 'blankNode' || type === 'quad') {\n    return type;\n  }\n  return undefined;\n}\nexport type TermType = 'namedNode' | 'literal' | 'blankNode' | 'quad';\nexport type TermExpression = IExpressionProps & {\n  expressionType: ExpressionType.Term;\n  termType: TermType;\n  str: () => string;\n  coerceEBV: () => boolean;\n  toRDF: () => RDF.Term;\n};\n\nexport type VariableExpression = IExpressionProps & {\n  expressionType: ExpressionType.Variable;\n  name: string;\n};\n\n// Export type Application = SimpleApplication | SpecialApplication;\nexport type SimpleApplication = (args: TermExpression[]) => TermExpression;\nexport type SimpleApplicationTuple<T> = (args: T) => TermExpression;\nexport type AsyncExtensionApplication = (args: TermExpression[]) => Promise<TermExpression>;\n\nexport type SpecialApplicationAsync = (context: EvalContextAsync) => Promise<TermExpression>;\n\nexport type SpecialApplicationSync = (context: EvalContextSync) => TermExpression;\n"]}